Authentication

Two different ways of attacking a database and decrypting passwords

-   Brute Force Attack
    --> aaaaaa -> 3fdr\$
    --> aaaaab -> 4dzq

Generating a list of hashes and compare it to list of hash passwords in order to decrypt

in a hash

\$2a --> indicates use version 2 of bcrypt

-   Dictionary Attack

password1 -- 3de
passwort -- fzq
123456 -- gq3
donaldtrump
1234567

sha1, mda5, bcrypt

sha1, mda5 --> really bad because fast to crack

bcryt --> better, slow to crack, can take up to 12 years

bcrypt takes the
password like

cat3 + "edfz"(which represents the salt)
= cat33dfz

turn it into

$2a$1da$fagwras$asdfa somethingsomething...

PETITION PART 3

registration and Login

registration

-   put userId in cookie, and the value of the userId cookie should be the id that was generated by postgres when we did the INSERT

login

-   server-side -- we need to get the user's hashed password from the database, and then compare that hash with the password we got from the input field
-   if they match then store userId in cookie

petition

-   remove input fields for first and last (because we're getting the user's first and last name from the registration / login pages)
-   greet user by name

logout

-   delete everything in the user's cookie
-   `req.session = null`
-   logout can happen on GET or POST request

only certain user's will have permission to view certain pages.

For example, if a user is NOT logged in or registered they should not be allowed to see any other page of your website other than registration or login.

If the user hasn't signed the petition yet, the user should not be able to see the "/signed" page.

---

FINISHED

registration

-   new template with <form> and 4 input fields
-   server-side - hash the password and INSERT first, last, email and hashed password into the new users table
